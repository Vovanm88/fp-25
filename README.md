# Лабораторная работа №3

**Студент:** 367390, Мельников Владимир Владимирович  
**Предмет:** Функциональное программирование

---

## Содержание

1. [Требования к разработанному ПО](#1-требования-к-разработанному-по)
2. [Ключевые элементы реализации](#2-ключевые-элементы-реализации)
3. [Ввод/вывод программы](#3-вводвывод-программы)
4. [Выводы](#4-выводы)

---

## 1. Требования к разработанному ПО

### 1.1. Цель работы

Получить навыки работы с вводом/выводом, потоковой обработкой данных, командной строкой.

### 1.2. Функциональные требования

Программа реализует интерполяцию функций в потоковом режиме со следующими возможностями:

- **Алгоритмы интерполяции:**
  - Линейная интерполяция (обязательно)
  - Интерполяция методом Лагранжа
  - Интерполяция методом Ньютона

- **Настройки через аргументы командной строки:**
  - Выбор алгоритмов интерполяции (можно использовать несколько одновременно)
  - Частота дискретизации результирующих данных (шаг)
  - Размер окна для алгоритмов, работающих с группой точек

- **Формат входных данных:**
  - Текстовый формат (CSV-подобный): `x;y`, `x\ty` или `x y`
  - Данные подаются на стандартный ввод
  - Входные данные отсортированы по возрастанию x

- **Формат выходных данных:**
  - Вывод на стандартный вывод
  - Формат: `метод: x y`

- **Потоковый режим работы:**
  - Программа ожидает данные на стандартном вводе
  - По мере получения достаточного количества данных выводит рассчитанные точки
  - Работает как утилита командной строки (например, `cat data.txt | lab3 --linear --step 0.5`)

### 1.3. Описание алгоритмов

#### Линейная интерполяция

Линейная интерполяция между двумя точками $(x_1, y_1)$ и $(x_2, y_2)$ вычисляется по формуле:

$$y = y_1 + \frac{x - x_1}{x_2 - x_1} \cdot (y_2 - y_1)$$

где $x$ — точка, для которой вычисляется значение.

#### Интерполяция методом Лагранжа

Для набора точек $(x_i, y_i)$, $i = 0, \ldots, n-1$, значение в точке $x$ вычисляется по формуле:

$$L(x) = \sum_{i=0}^{n-1} y_i \prod_{\substack{j=0 \\ j \neq i}}^{n-1} \frac{x - x_j}{x_i - x_j}$$

#### Интерполяция методом Ньютона

Использует разделённые разности. Сначала строится таблица разделённых разностей:

$$f[x_i] = y_i$$

$$f[x_i, x_{i+1}, \ldots, x_{i+j}] = \frac{f[x_{i+1}, \ldots, x_{i+j}] - f[x_i, \ldots, x_{i+j-1}]}{x_{i+j} - x_i}$$

Затем значение вычисляется по формуле Ньютона:

$$N(x) = f[x_0] + \sum_{i=1}^{n-1} f[x_0, \ldots, x_i] \prod_{j=0}^{i-1} (x - x_j)$$

### 1.4. Архитектура программы

Программа организована следующим образом:

```
    +---------------------------+
    | обработка входного потока |
    +---------------------------+
            |
            | поток / список / последовательность точек
            v
    +-----------------------+      +------------------------------+
    | алгоритм интерполяции |<-----| генератор точек, для которых |
    +-----------------------+      | необходимо вычислить         |
            |                      | промежуточные значения       |
            |                      +------------------------------+
            |
            | поток / список / последовательность рассчитанных точек
            v
    +------------------------+
    | печать выходных данных |
    +------------------------+
```

### 1.5. Потоковый режим работы

Для алгоритмов, работающих с группой точек, используется скользящее окно:

```
o o o o o o . . x x x
  x x x . . o . . x x x
    x x x . . o . . x x x
      x x x . . o . . x x x
        x x x . . o . . x x x
          x x x . . o . . x x x
            x x x . . o o o o o o EOF
```

где:
- каждая строка — окно данных, на основании которых производится расчёт алгоритма;
- строки сменяются по мере поступления в систему новых данных (старые данные удаляются из окна, новые — добавляются);
- `o` — рассчитанные данные:
  - большинство окон используется для расчёта всего одной точки, так как именно в "центре" результат наиболее точен;
  - первое и последнее окно используются для расчёта большого количества точек, так лучших данных для расчёта у нас не будет;
- `.` — точки, задействованные в расчёте значения `o`;
- `x` — точки, расчёт которых для "окон" не требуется.

---

## 2. Ключевые элементы реализации

### 2.1. Структура проекта

```
fp-25/
├── lib/
│   ├── Interpolation.ml    # Алгоритмы интерполяции
│   ├── Interpolation.mli
│   ├── Stream.ml           # Потоковая обработка данных
│   ├── Stream.mli
│   ├── Input.ml            # Парсинг входных данных
│   ├── Output.ml           # Форматирование вывода
│   └── Output.mli
├── bin/
│   └── main.ml             # Точка входа, парсинг аргументов
└── test/
    └── test_lab3_pbt.ml    # Тесты
```

### 2.2. Типы данных

```ocaml
type point = { x : float; y : float }

type interpolation_method = Linear | Lagrange | Newton
```

### 2.3. Алгоритмы интерполяции (`lib/Interpolation.ml`)

#### Линейная интерполяция

```ocaml
let linear_interpolate p1 p2 x =
  if p1.x = p2.x then p1.y
  else
    let t = (x -. p1.x) /. (p2.x -. p1.x) in
    p1.y +. (t *. (p2.y -. p1.y))
```

#### Интерполяция Лагранжа

```ocaml
let lagrange_interpolate points x =
  let n = List.length points in
  let points_list = Array.of_list points in
  let lagrange_basis i =
    let xi = points_list.(i).x in
    let yi = points_list.(i).y in
    let product = ref 1.0 in
    for j = 0 to n - 1 do
      if i <> j then
        let xj = points_list.(j).x in
        product := !product *. ((x -. xj) /. (xi -. xj))
    done;
    !product *. yi
  in
  let sum = ref 0.0 in
  for i = 0 to n - 1 do
    sum := !sum +. lagrange_basis i
  done;
  !sum
```

#### Интерполяция Ньютона

```ocaml
let newton_interpolate points x =
  let n = List.length points in
  let points_list = Array.of_list points in
  let dd = Array.make_matrix n n 0.0 in
  (* Построение таблицы разделённых разностей *)
  for i = 0 to n - 1 do
    dd.(i).(0) <- points_list.(i).y
  done;
  for j = 1 to n - 1 do
    for i = 0 to n - j - 1 do
      let xi = points_list.(i).x in
      let xij = points_list.(i + j).x in
      dd.(i).(j) <- (dd.(i + 1).(j - 1) -. dd.(i).(j - 1)) /. (xij -. xi)
    done
  done;
  (* Вычисление значения по формуле Ньютона *)
  let result = ref dd.(0).(n - 1) in
  for i = n - 2 downto 0 do
    result := (!result *. (x -. points_list.(i).x)) +. dd.(0).(i)
  done;
  !result
```

### 2.4. Потоковая обработка (`lib/Stream.ml`)

Основная функция `process_stream` реализует потоковую обработку:

```ocaml
let process_stream ~methods ~step ~window_size ~parse_line ~print_point =
  let points_buffer = ref [] in
  let last_computed_x = ref (List.map (fun m -> (m, None)) methods) in
  
  let rec process_line () =
    match read_line () with
    | exception End_of_file -> 
        (* Обработка оставшихся точек при завершении ввода *)
        ...
    | line -> 
        (* Парсинг строки, добавление точки в буфер *)
        (* Обработка каждого метода интерполяции *)
        (* Обновление скользящего окна *)
        process_line ()
  in
  process_line ()
```

Ключевые особенности:
- Использование рекурсивной функции `process_line` для обработки потока
- Буферизация точек с ограничением размера окна
- Отслеживание последней вычисленной точки для каждого метода
- Генерация промежуточных точек с заданным шагом

### 2.5. Парсинг входных данных (`lib/Input.ml`)

```ocaml
let parse_line line =
  try
    let parts =
      if String.contains line ';' then String.split_on_char ';' line
      else if String.contains line '\t' then String.split_on_char '\t' line
      else String.split_on_char ' ' line
    in
    let parts = List.filter (fun s -> String.trim s <> "") parts in
    match parts with
    | [ x_str; y_str ] ->
        let x = float_of_string (String.trim x_str) in
        let y = float_of_string (String.trim y_str) in
        Some { x; y }
    | _ -> None
  with _ -> None
```

Поддерживаются форматы: `x;y`, `x\ty`, `x y`.

### 2.6. Форматирование вывода (`lib/Output.ml`)

```ocaml
let print_point label point =
  Printf.printf "%s: %.6g %.6g\n" label point.x point.y;
  flush stdout
```

### 2.7. Парсинг аргументов командной строки (`bin/main.ml`)

```ocaml
let parse_args () =
  let step = ref 1.0 in
  let methods = ref [] in
  let window_size = ref 2 in
  let args =
    [
      ( "--step", Arg.Set_float step, "STEP Step size (default: 1.0)" );
      ( "--linear", Arg.Unit (fun () -> methods := Linear :: !methods), 
        " Use linear interpolation" );
      ( "--lagrange", Arg.Unit (fun () -> methods := Lagrange :: !methods), 
        " Use Lagrange interpolation" );
      ( "--newton", Arg.Unit (fun () -> methods := Newton :: !methods), 
        " Use Newton interpolation" );
      ( "-n", Arg.Set_int window_size, 
        "N Window size for Lagrange/Newton (default: 2)" );
    ]
  in
  Arg.parse args (fun _ -> ()) 
    "Usage: lab3 [--linear|--lagrange|--newton] [-n N] [--step STEP]";
  if !methods = [] then (
    prerr_endline "Error: at least one interpolation method must be specified";
    exit 1);
  (!methods, !step, !window_size)
```

---

## 3. Ввод/вывод программы

### 3.1. Использование

```bash
lab3 [--linear|--lagrange|--newton] [-n N] [--step STEP]
```

### 3.2. Аргументы командной строки

- `--linear` — использовать линейную интерполяцию
- `--lagrange` — использовать интерполяцию методом Лагранжа
- `--newton` — использовать интерполяцию методом Ньютона
- `-n N` — размер окна для методов Лагранжа и Ньютона (по умолчанию: 2)
- `--step STEP` — шаг дискретизации (по умолчанию: 1.0)

Можно указать несколько методов одновременно.

### 3.3. Примеры использования

#### Пример 1: Линейная интерполяция

```bash
$ echo -e "0 0\n1 1\n2 2" | lab3 --linear --step 0.7
linear: 0 0
linear: 0.7 0.7
linear: 1.4 1.4
linear: 2 2
```

#### Пример 2: Интерполяция Ньютона с окном 4

```bash
$ echo -e "0 0\n1 1\n2 2\n3 3\n4 4\n5 5\n7 7\n8 8" | \
  lab3 --newton -n 4 --step 0.5
newton: 0 0
newton: 0.5 0.5
newton: 1 1
newton: 1.5 1.5
newton: 2 2
newton: 2.5 2.5
newton: 3 3
newton: 3.5 3.5
newton: 4 4
newton: 4.5 4.5
newton: 5 5
newton: 5.5 5.5
newton: 6 6
newton: 6.5 6.5
newton: 7 7
newton: 7.5 7.5
newton: 8 8
```

#### Пример 3: Несколько методов одновременно

```bash
$ echo -e "0 0\n1 1\n2 4" | lab3 --linear --newton -n 3 --step 0.5
linear: 0 0
newton: 0 0
linear: 0.5 0.5
newton: 0.5 0.125
linear: 1 1
newton: 1 1
linear: 1.5 2.5
newton: 1.5 2.125
linear: 2 4
newton: 2 4
```

#### Пример 4: Работа с файлом

```bash
$ cat data.csv | lab3 --linear --lagrange -n 3 --step 0.1
```

### 3.4. Формат входных данных

Поддерживаются следующие разделители:
- Пробел: `0 0`
- Табуляция: `0\t0`
- Точка с запятой: `0;0`

Входные данные должны быть отсортированы по возрастанию x.

### 3.5. Формат выходных данных

Каждая строка имеет формат:
```
метод: x y
```

где:
- `метод` — название метода интерполяции (`linear`, `lagrange`, `newton`)
- `x` — координата x (формат: `%.6g`)
- `y` — вычисленное значение y (формат: `%.6g`)

---

## 4. Выводы

### 4.1. Использованные приёмы программирования

#### Функциональный стиль

Программа реализована в функциональном стиле с использованием:
- **Чистых функций** для алгоритмов интерполяции (без побочных эффектов)
- **Рекурсии** для обработки потока данных вместо императивных циклов
- **Функций высшего порядка** для абстракции операций (например, `List.iter`, `List.map`)

#### Разделение ответственности

Архитектура программы следует принципу разделения ответственности:
- **`Interpolation.ml`** — чистые алгоритмы интерполяции, независимые от ввода/вывода
- **`Input.ml`** — парсинг входных данных
- **`Output.ml`** — форматирование вывода
- **`Stream.ml`** — оркестрация потоковой обработки
- **`main.ml`** — точка входа и парсинг аргументов

Это обеспечивает:
- Тестируемость каждого компонента
- Возможность переиспользования алгоритмов
- Простоту модификации и расширения

#### Потоковая обработка

Реализация потокового режима использует:
- **Рекурсивную обработку** входного потока через `read_line ()`
- **Буферизацию** с ограничением размера окна
- **Ленивые вычисления** через генерацию точек по требованию

Особенности реализации:
- Программа не загружает все данные в память, а обрабатывает их по мере поступления
- Использование скользящего окна позволяет эффективно работать с алгоритмами, требующими несколько точек
- Отслеживание последней вычисленной точки предотвращает дублирование результатов

#### Работа с опциональными значениями

Использование типа `option` для обработки ошибок парсинга:
```ocaml
val parse_line : string -> point option
```

Это позволяет безопасно обрабатывать некорректные входные данные без исключений.

#### Модульность

Программа организована в виде библиотеки (`lib/`) и исполняемого файла (`bin/`), что:
- Позволяет переиспользовать алгоритмы в других проектах
- Упрощает тестирование
- Соответствует идиоматичному стилю OCaml

### 4.2. Преимущества реализации

1. **Масштабируемость**: Программа может обрабатывать потоки данных произвольного размера
2. **Гибкость**: Поддержка нескольких алгоритмов интерполяции с возможностью комбинирования
3. **Расширяемость**: Легко добавить новые алгоритмы интерполяции
4. **Тестируемость**: Чистые функции легко тестировать
5. **Идиоматичность**: Код следует принятым в OCaml практикам

### 4.3. Возможные улучшения

1. **Обработка ошибок**: Более детальная обработка некорректных входных данных
2. **Производительность**: Оптимизация алгоритмов для больших окон
3. **Валидация**: Проверка отсортированности входных данных
4. **Документация**: Расширение комментариев в коде

---

## Заключение

В ходе выполнения лабораторной работы была реализована программа для потоковой интерполяции функций, использующая три метода интерполяции: линейную, Лагранжа и Ньютона. Программа демонстрирует применение функционального стиля программирования, разделения ответственности и потоковой обработки данных в языке OCaml.

Реализация соответствует всем требованиям задания и может использоваться как утилита командной строки для обработки потоков данных.
