# Lossy-аудиокодек

## Общие требования

- программа должна быть реализована в функциональном стиле;
- требуется использовать идиоматичный для технологии стиль программирования;
- задание и коллектив должны быть согласованы;
- допустима совместная работа над одним заданием.

## Требования к разработанному ПО

Проект представляет собой lossy-аудиокодек, реализованный на OCaml. Кодек выполняет сжатие аудиофайлов с потерями качества, используя преобразования в частотную область (MDCT), разбиение на частотные полосы, квантование и энтропийное кодирование.

### Описание алгоритма

Кодек использует двухуровневое MDCT-преобразование для эффективного представления аудиосигнала в частотной области. Сигнал разбивается на сегменты с адаптивным оконным преобразованием, затем применяется MDCT для получения частотных коэффициентов. Коэффициенты разбиваются на частотные полосы, после чего выполняется квантование с адаптивным выбором уровней квантования на основе порога SNR.

## Реализация

### Блок-схема процесса кодирования

```
Входной аудиосигнал
        |
        v
[Сжатие динамического диапазона]
        |
        v
[LR → Mid-Side преобразование]
        |
        v
[Замена тишины после громких участков]
        |
        v
[Адаптивная сегментация]
        |
        v
[Оконное преобразование (overlapping windows)]
        |
        v
[MDCT Level 1]
        |
        v
[Разбиение на частотные полосы]
        |
        v
[IMDCT для каждой полосы]
        |
        v
[MDCT Level 2]
        |
        v
[Квантование с адаптивным выбором уровней]
        |
        v
[Сериализация]
        |
        v
Выходной файл (.audc)
```

### Блок-схема процесса декодирования

```
Входной файл (.audc)
        |
        v
[Десериализация]
        |
        v
[Деquantization]
        |
        v
[IMDCT Level 2]
        |
        v
[MDCT Level 1 для каждой полосы]
        |
        v
[Объединение частотных полос]
        |
        v
[IMDCT финальное]
        |
        v
[Overlap-add окон]
        |
        v
[Pass-through тишины]
        |
        v
[Mid-Side → LR преобразование]
        |
        v
[Распаковка динамического диапазона]
        |
        v
Восстановленный аудиосигнал
```

## Проблемы производительности и оптимизации

### FFT и MDCT

Реализация FFT и MDCT была позаимствована из FFmpeg и переписана на OCaml. Исходный код FFmpeg использует оптимизированные алгоритмы split-radix FFT с O(n log n) сложностью. При портировании на OCaml были сохранены основные оптимизации:

- Split-radix перестановка для минимизации операций
- Предвычисленные таблицы косинусов
- Специализированные функции для малых размеров (FFT-4, FFT-8)
- Эффективное использование массивов для хранения промежуточных результатов

### Оптимизация List → Array

В процессе разработки были выявлены серьезные проблемы производительности при использовании списков (List) для операций с большими объемами данных:

1. **Доступ по индексу**: `List.nth` имеет сложность O(n), что критично при частых обращениях
2. **Конкатенация**: `@` оператор создает новые списки, что приводит к избыточным аллокациям
3. **Итерации**: Множественные проходы по спискам для вычислений

**Примеры оптимизаций:**

- **Reader/Writer модули**: Переписаны с использованием массивов для O(1) доступа к байтам
- **Сегментация и обработка**: Конвертация списков в массивы для операций с индексами
- **MDCT коэффициенты**: Использование `Array.sub` вместо `List.init + List.nth` для извлечения частотных полос

```ocaml
(* Было: O(n²) *)
let band = List.init (end_idx - start_idx + 1) (fun i -> 
  List.nth mdct_coeffs (start_idx + i))

(* Стало: O(n) *)
let coeffs_array = Array.of_list mdct_coeffs in
let band = Array.to_list (Array.sub coeffs_array start_idx (end_idx - start_idx + 1))
```

Эти оптимизации позволили значительно ускорить обработку больших аудиофайлов, особенно в критических участках кода, таких как сериализация/десериализация и обработка частотных коэффициентов.

## Выводы

При разработке lossy-аудиокодека были использованы следующие приемы функционального программирования:

1. **Иммутабельные структуры данных**: Основные типы данных (сегменты, треки) используют иммутабельные записи
2. **Композиция функций**: Пайплайн кодирования/декодирования построен как композиция чистых функций
3. **Паттерн-матчинг**: Активное использование pattern matching для обработки опциональных значений и вариантных типов
4. **Высокоуровневые абстракции**: Использование `List.map`, `List.fold_left`, `List.filter` для декларативного описания преобразований

Однако для достижения приемлемой производительности пришлось прибегнуть к императивным конструкциям:

- **Мутабельные массивы**: Для критических участков кода (FFT, MDCT, сериализация)
- **Императивные циклы**: `for` и `while` для операций с массивами
- **Рефы**: Для накопления состояния в некоторых алгоритмах

Это демонстрирует важность баланса между чистотой функционального стиля и практическими требованиями производительности. В OCaml такой гибридный подход является идиоматичным и позволяет сочетать выразительность функционального программирования с эффективностью императивных конструкций там, где это необходимо.
